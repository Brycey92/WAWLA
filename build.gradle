buildscript {

    repositories {

        jcenter()

        maven {

            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }

        maven {

            url "https://plugins.gradle.org/m2/"
        }
        
    }

    dependencies {

        classpath 'net.minecraftforge.gradle:ForgeGradle:2.2-SNAPSHOT'
        classpath 'gradle.plugin.com.matthewprenger:CurseGradle:1.0.7'
    }
}

apply plugin: 'maven'
apply plugin: 'net.minecraftforge.gradle.forge'
apply plugin: 'com.matthewprenger.cursegradle'

sourceCompatibility = 1.8
targetCompatibility = 1.8

group = 'net.darkhax.wawla'
archivesBaseName = 'Wawla'
version = getVersionFromJava(file('src/main/java/net/darkhax/wawla/lib/Constants.java'))

//Defines the MC environment information.
minecraft {

    version = "${version_forge}"
    mappings = "${version_mcp}"
    runDir = 'run'
    useDepAts = true
}

//Defines basic patterns for pulling various dependencies.
repositories {

    maven {
    
        url 'http://tehnut.info/maven'
    }
    
    maven {
    
        url 'https://jitpack.io'
    }
}

dependencies {

    deobfCompile "mcp.mobius.waila:Hwyla:${version_hwyla}"
}

//Handles basic resources such as mcmod.info
processResources {

    inputs.property 'version', project.version
    inputs.property 'mcversion', project.minecraft.version

    from(sourceSets.main.resources.srcDirs) {

        include 'mcmod.info'
        expand 'version': project.version, 'mcversion': project.minecraft.version
    }

    from(sourceSets.main.resources.srcDirs) {

        exclude 'mcmod.info'
    }
    
    rename '(.+_at.cfg)', 'META-INF/$1'
}

jar {

	manifest {
	
		attributes 'FMLAT': 'wawla_at.cfg'
	}
}

//Pulls the build version from a Java file.
String getVersionFromJava(File file) {

    String release = '0';
    String update = '0';
    String patch = '0';

    String build = System.getenv('BUILD_NUMBER') ? System.getenv("BUILD_NUMBER") : "0";
    def outfile = "";
    def ln = System.getProperty('line.separator')

    String prefix = "public static final String VERSION_NUMBER = \"";
    file.eachLine {
        String s ->

            String v = s.trim();

        if (v.startsWith(prefix)) {

            v = v.substring(prefix.length(), v.length() - 2);
            String[] pts = v.split("\\.");

            release = pts[0];
            update = pts[1];
            patch = pts[2];
            s = s.replaceAll(".0\";", ".${build}\";");
        }

        outfile += (s + ln);
    }

    file.write(outfile);

    return "${version_minecraft}-$release.$update.$patch.$build";
}

//Creates the source jar.
task sourcesJar(type: Jar, dependsOn: classes) {

    from sourceSets.main.allSource
    classifier = 'sources'
}

//Creates the JavaDoc jar.
task javadocJar(type: Jar, dependsOn: javadoc) {

    from javadoc.destinationDir
    classifier = 'javadoc'
}

//Creates the deobfuscated jar.
task deobfJar(type: Jar) {

    from sourceSets.main.output
    classifier = "deobf"
}

//Adds the deobf, source and javadoc jars to the build artifacts.
artifacts {

    archives deobfJar
    archives sourcesJar
    archives javadocJar
}

//Uploads the artifacts to the maven server.
uploadArchives {

    repositories {

        mavenDeployer {

            repository(url: "file:///var/www/html/maven")
        }
    }
}

//Prevents incomplete JavaDocs from preventing a build on Java 8.
if (JavaVersion.current().isJava8Compatible()) {

    allprojects {

        tasks.withType(Javadoc) {

            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }
}

//Provides the basic CurseForge upload details
curseforge {

    //Sets the API from the system environment, if available.
    apiKey = System.getenv("curseForgeApiKey") ? System.getenv("curseForgeApiKey") : "0";

    project {

        //Sets the Project ID from the system environment, if available.
        id = System.getenv("projectId") ? System.getenv("projectId") : "0";

        releaseType = 'alpha';
        changelog = new File(project.buildDir.getPath() + '/changelog.md')
	    changelogType = 'markdown'

        addGameVersion "${version_minecraft}"
        
        //Adds main jar, deobf jar, source jar, and javadoc jar to the upload.
        mainArtifact(jar) {
          
            relations {

                //Adds the file relations to the upload.
                optionalLibrary 'waila'
                optionalLibrary 'hwyla'
            }
        }
        
        addArtifact(deobfJar)
        addArtifact(sourcesJar)
        addArtifact(javadocJar)
    }
}

def getHeadCommitMessage() {
	def headProc = "git log -1 --format=%B".execute()
	headProc.waitForOrKill(1000)
	assert headProc.exitValue() == 0, headProc.err.text
	return headProc.in.text.trim()
}

def getLastTaggedCommit() {
	return getLastTaggedCommit(0)
}

def getLastTaggedCommit(int skip) {
	def lastTagProc = "git rev-list HEAD --tags --max-count=1 --no-walk --skip=$skip".execute()
	lastTagProc.waitForOrKill(1000)
	assert lastTagProc.exitValue() == 0, lastTagProc.err.text
	def lastTag = lastTagProc.in.text.trim()

	if (lastTag.equals(getHeadCommit()))
		return getLastTaggedCommit(1)
	else
		return lastTag
}

def getHeadCommit() {
	def headProc = "git rev-parse HEAD".execute()
	headProc.waitForOrKill(1000)
	assert headProc.exitValue() == 0, headProc.err.text
	return headProc.in.text.trim()
}

def getChangelogSince(String commitSHA, String format="- %B") {
	def changelog = ""
	def range = commitSHA.isEmpty() ? "HEAD" : "$commitSHA..HEAD"
	def cmd = ["git", "log", "--no-merges", "--format=$format", "$range"]
	def changelogProc = cmd.execute()
	changelogProc.in.eachLine { line ->
		if (!line.isEmpty()) {
			changelog += line + "\n"
		}
	}
	changelogProc.err.eachLine { line -> println line }
	return changelog
}

def sanitizeChangelog(String changelog) {
	def splitChangelog = changelog.split(/(^|\n)\- /)
	def sanitizedChangelog = ""
	splitChangelog.each { change ->
		if (!change.isEmpty() && !change.contains(":skip:"))
		sanitizedChangelog += "\n- " + change.replaceAll(/\n\n/) { match ->
			return "\n"
		}
	}
	return sanitizedChangelog
}

task changelog() << {
	def changelogFile = new File(project.buildDir.getPath() + '/changelog.md')
	if (!changelogFile.getParentFile().exists())
		changelogFile.getParentFile().mkdirs()
	changelogFile.delete()

	def lastTag = getLastTaggedCommit()
	def changelog = getChangelogSince(lastTag)
	def sanitizedChangelog = sanitizeChangelog(changelog)
	println sanitizedChangelog
	changelogFile << sanitizedChangelog
}